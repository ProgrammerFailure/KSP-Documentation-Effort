<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Kerbal Space Program: Steamworks.SteamInventory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doc_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ksp_logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kerbal Space Program
   &#160;<span id="projectnumber">1.12.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Events</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_steamworks.html">Steamworks</a></li><li class="navelem"><a class="el" href="class_steamworks_1_1_steam_inventory.html">SteamInventory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_steamworks_1_1_steam_inventory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Steamworks.SteamInventory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae98959c5f0aaf504b294977af7ce237b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#ae98959c5f0aaf504b294977af7ce237b">AddPromoItem</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle, <a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a> itemDef)</td></tr>
<tr class="separator:ae98959c5f0aaf504b294977af7ce237b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5959720e8bb143147312eb58d876f7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a9a5959720e8bb143147312eb58d876f7">AddPromoItems</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle, <a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[] pArrayItemDefs, uint unArrayLength)</td></tr>
<tr class="separator:a9a5959720e8bb143147312eb58d876f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4b3cb51ed01cb541224cac57153657"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#aeb4b3cb51ed01cb541224cac57153657">CheckResultSteamID</a> (<a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> resultHandle, <a class="el" href="struct_steamworks_1_1_c_steam_i_d.html">CSteamID</a> steamIDExpected)</td></tr>
<tr class="separator:aeb4b3cb51ed01cb541224cac57153657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9418d7218b11273c49fc58774dabfb84"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a9418d7218b11273c49fc58774dabfb84">ConsumeItem</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle, <a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a> itemConsume, uint unQuantity)</td></tr>
<tr class="separator:a9418d7218b11273c49fc58774dabfb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca6c5b902f425359f71b3ad4a3e606e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a0ca6c5b902f425359f71b3ad4a3e606e">DeserializeResult</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pOutResultHandle, byte[] pBuffer, uint unBufferSize, bool bRESERVED_MUST_BE_FALSE=false)</td></tr>
<tr class="separator:a0ca6c5b902f425359f71b3ad4a3e606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be2f0c4bc55efde7015b3b083353f93"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a9be2f0c4bc55efde7015b3b083353f93">DestroyResult</a> (<a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> resultHandle)</td></tr>
<tr class="separator:a9be2f0c4bc55efde7015b3b083353f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbc45f75a767abc0b3c6f4de4b90b23"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a4fbc45f75a767abc0b3c6f4de4b90b23">ExchangeItems</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle, <a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[] pArrayGenerate, uint[] punArrayGenerateQuantity, uint unArrayGenerateLength, <a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>[] pArrayDestroy, uint[] punArrayDestroyQuantity, uint unArrayDestroyLength)</td></tr>
<tr class="separator:a4fbc45f75a767abc0b3c6f4de4b90b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05c95022ae2c610dc575da4252e9fca"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#ae05c95022ae2c610dc575da4252e9fca">GenerateItems</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle, <a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[] pArrayItemDefs, uint[] punArrayQuantity, uint unArrayLength)</td></tr>
<tr class="separator:ae05c95022ae2c610dc575da4252e9fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c525e42e012f03a76c4eb5fbd989f26"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a0c525e42e012f03a76c4eb5fbd989f26">GetAllItems</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle)</td></tr>
<tr class="separator:a0c525e42e012f03a76c4eb5fbd989f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf3d4cf9600484eb407b00e8749bb75"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a8cf3d4cf9600484eb407b00e8749bb75">GetEligiblePromoItemDefinitionIDs</a> (<a class="el" href="struct_steamworks_1_1_c_steam_i_d.html">CSteamID</a> steamID, <a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[] pItemDefIDs, ref uint punItemDefIDsArraySize)</td></tr>
<tr class="separator:a8cf3d4cf9600484eb407b00e8749bb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7a17b85a76a5b96bdf7e2952e58704"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#aad7a17b85a76a5b96bdf7e2952e58704">GetItemDefinitionIDs</a> (<a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[] pItemDefIDs, out uint punItemDefIDsArraySize)</td></tr>
<tr class="separator:aad7a17b85a76a5b96bdf7e2952e58704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8ae71ee266a730049776224cb99574"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a9b8ae71ee266a730049776224cb99574">GetItemDefinitionProperty</a> (<a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a> iDefinition, string pchPropertyName, out string pchValueBuffer, ref uint punValueBufferSizeOut)</td></tr>
<tr class="separator:a9b8ae71ee266a730049776224cb99574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4324bfdac5e0b51f46a7d462cd5e6db"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#aa4324bfdac5e0b51f46a7d462cd5e6db">GetItemsByID</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle, <a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>[] pInstanceIDs, uint unCountInstanceIDs)</td></tr>
<tr class="separator:aa4324bfdac5e0b51f46a7d462cd5e6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be0bc2460ecd32ffba301703616ad3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#af3be0bc2460ecd32ffba301703616ad3">GetResultItemProperty</a> (<a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> resultHandle, uint unItemIndex, string pchPropertyName, out string pchValueBuffer, ref uint punValueBufferSizeOut)</td></tr>
<tr class="separator:af3be0bc2460ecd32ffba301703616ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba52fdab1a05f490d8d262b76d24276"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a2ba52fdab1a05f490d8d262b76d24276">GetResultItems</a> (<a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> resultHandle, <a class="el" href="struct_steamworks_1_1_steam_item_details__t.html">SteamItemDetails_t</a>[] pOutItemsArray, ref uint punOutItemsArraySize)</td></tr>
<tr class="separator:a2ba52fdab1a05f490d8d262b76d24276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59adc6a4bbbdc208ff0e6333ef034b41"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_steamworks.html#aa3f8a4f6fec6a62bc154bbaab3cb7522">EResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a59adc6a4bbbdc208ff0e6333ef034b41">GetResultStatus</a> (<a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> resultHandle)</td></tr>
<tr class="separator:a59adc6a4bbbdc208ff0e6333ef034b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eb4a3d0eab8b2ba39ce461a2027851"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#ab3eb4a3d0eab8b2ba39ce461a2027851">GetResultTimestamp</a> (<a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> resultHandle)</td></tr>
<tr class="separator:ab3eb4a3d0eab8b2ba39ce461a2027851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3409a61317f1e9ec0d8c2aedf7372e7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#aa3409a61317f1e9ec0d8c2aedf7372e7">GrantPromoItems</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle)</td></tr>
<tr class="separator:aa3409a61317f1e9ec0d8c2aedf7372e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4d1ecc084ec1a9be1983d6edc73ecb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a8b4d1ecc084ec1a9be1983d6edc73ecb">LoadItemDefinitions</a> ()</td></tr>
<tr class="separator:a8b4d1ecc084ec1a9be1983d6edc73ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ed0aaa8b1268ea14bdfadfd90e8e51"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_steamworks_1_1_steam_a_p_i_call__t.html">SteamAPICall_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a48ed0aaa8b1268ea14bdfadfd90e8e51">RequestEligiblePromoItemDefinitionsIDs</a> (<a class="el" href="struct_steamworks_1_1_c_steam_i_d.html">CSteamID</a> steamID)</td></tr>
<tr class="separator:a48ed0aaa8b1268ea14bdfadfd90e8e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bcfa59dbc3b372c5532de814eeb785"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#aa2bcfa59dbc3b372c5532de814eeb785">SendItemDropHeartbeat</a> ()</td></tr>
<tr class="separator:aa2bcfa59dbc3b372c5532de814eeb785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa7d01a9f1c9618074b9305d1f4d08f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a4fa7d01a9f1c9618074b9305d1f4d08f">SerializeResult</a> (<a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> resultHandle, byte[] pOutBuffer, out uint punOutBufferSize)</td></tr>
<tr class="separator:a4fa7d01a9f1c9618074b9305d1f4d08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd5542782c2e5ce0ce6ab72a4c68856"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#a4cd5542782c2e5ce0ce6ab72a4c68856">TradeItems</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle, <a class="el" href="struct_steamworks_1_1_c_steam_i_d.html">CSteamID</a> steamIDTradePartner, <a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>[] pArrayGive, uint[] pArrayGiveQuantity, uint nArrayGiveLength, <a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>[] pArrayGet, uint[] pArrayGetQuantity, uint nArrayGetLength)</td></tr>
<tr class="separator:a4cd5542782c2e5ce0ce6ab72a4c68856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd2236b70d13598619d122696b4bcff"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#afcd2236b70d13598619d122696b4bcff">TransferItemQuantity</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle, <a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a> itemIdSource, uint unQuantity, <a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a> itemIdDest)</td></tr>
<tr class="separator:afcd2236b70d13598619d122696b4bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ebb38efa007f6189382f0a55dc35ec"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_steamworks_1_1_steam_inventory.html#af1ebb38efa007f6189382f0a55dc35ec">TriggerItemDrop</a> (out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a> pResultHandle, <a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a> dropListDefinition)</td></tr>
<tr class="separator:af1ebb38efa007f6189382f0a55dc35ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae98959c5f0aaf504b294977af7ce237b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.AddPromoItem </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>&#160;</td>
          <td class="paramname"><em>itemDef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><a class="el" href="class_steamworks_1_1_steam_inventory.html#ae98959c5f0aaf504b294977af7ce237b">AddPromoItem()</a> / <a class="el" href="class_steamworks_1_1_steam_inventory.html#a9a5959720e8bb143147312eb58d876f7">AddPromoItems()</a> are restricted versions of <a class="el" href="class_steamworks_1_1_steam_inventory.html#aa3409a61317f1e9ec0d8c2aedf7372e7">GrantPromoItems()</a>. Instead of</p>
<p>scanning for all eligible promotional items, the check is restricted to a single item</p>
<p>definition or set of item definitions. This can be useful if your game has custom UI for</p>
<p>showing a specific promo item to the user.</p>

</div>
</div>
<a class="anchor" id="a9a5959720e8bb143147312eb58d876f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.AddPromoItems </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[]&#160;</td>
          <td class="paramname"><em>pArrayItemDefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>unArrayLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb4b3cb51ed01cb541224cac57153657"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.CheckResultSteamID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>resultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_c_steam_i_d.html">CSteamID</a>&#160;</td>
          <td class="paramname"><em>steamIDExpected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Returns true if the result belongs to the target steam ID, false if the</p>
<p>result does not. This is important when using DeserializeResult, to verify</p>
<p>that a remote player is not pretending to have a different user's inventory.</p>

</div>
</div>
<a class="anchor" id="a9418d7218b11273c49fc58774dabfb84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.ConsumeItem </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>&#160;</td>
          <td class="paramname"><em>itemConsume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>unQuantity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><a class="el" href="class_steamworks_1_1_steam_inventory.html#a9418d7218b11273c49fc58774dabfb84">ConsumeItem()</a> removes items from the inventory, permanently. They cannot be recovered.</p>
<p>Not for the faint of heart - if your game implements item removal at all, a high-friction</p>
<p>UI confirmation process is highly recommended.</p>

</div>
</div>
<a class="anchor" id="a0ca6c5b902f425359f71b3ad4a3e606e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.DeserializeResult </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pOutResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>unBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRESERVED_MUST_BE_FALSE</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Deserializes a result set and verifies the signature bytes. Returns false</p>
<p>if bRequireFullOnlineVerify is set but Steam is running in Offline mode.</p>
<p>Otherwise returns true and then delivers error codes via GetResultStatus.</p>
<p>The bRESERVED_MUST_BE_FALSE flag is reserved for future use and should not</p>
<p>be set to true by your game at this time.</p>
<p>DeserializeResult has a potential soft-failure mode where the handle status</p>
<p>is set to k_EResultExpired. <a class="el" href="class_steamworks_1_1_steam_inventory.html#a2ba52fdab1a05f490d8d262b76d24276">GetResultItems()</a> still succeeds in this mode.</p>
<p>The "expired" result could indicate that the data may be out of date - not</p>
<p>just due to timed expiration (one hour), but also because one of the items</p>
<p>in the result set may have been traded or consumed since the result set was</p>
<p>generated. You could compare the timestamp from <a class="el" href="class_steamworks_1_1_steam_inventory.html#ab3eb4a3d0eab8b2ba39ce461a2027851">GetResultTimestamp()</a> to</p>
<p>ISteamUtils::GetServerRealTime() to determine how old the data is. You could</p>
<p>simply ignore the "expired" result code and continue as normal, or you</p>
<p>could challenge the player with expired data to send an updated result set.</p>

</div>
</div>
<a class="anchor" id="a9be2f0c4bc55efde7015b3b083353f93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Steamworks.SteamInventory.DestroyResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>resultHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Destroys a result handle and frees all associated memory.</p>

</div>
</div>
<a class="anchor" id="a4fbc45f75a767abc0b3c6f4de4b90b23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.ExchangeItems </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[]&#160;</td>
          <td class="paramname"><em>pArrayGenerate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint[]&#160;</td>
          <td class="paramname"><em>punArrayGenerateQuantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>unArrayGenerateLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>[]&#160;</td>
          <td class="paramname"><em>pArrayDestroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint[]&#160;</td>
          <td class="paramname"><em>punArrayDestroyQuantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>unArrayDestroyLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><a class="el" href="class_steamworks_1_1_steam_inventory.html#a4fbc45f75a767abc0b3c6f4de4b90b23">ExchangeItems()</a> is an atomic combination of item generation and consumption.</p>
<p>It can be used to implement crafting recipes or transmutations, or items which unpack</p>
<p>themselves into other items (e.g., a chest).</p>
<p>Exchange recipes are defined in the ItemDef, and explicitly list the required item</p>
<p>types and resulting generated type.</p>
<p>Exchange recipes are evaluated atomically by the Inventory Service; if the supplied</p>
<p>components do not match the recipe, or do not contain sufficient quantity, the</p>
<p>exchange will fail.</p>

</div>
</div>
<a class="anchor" id="ae05c95022ae2c610dc575da4252e9fca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.GenerateItems </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[]&#160;</td>
          <td class="paramname"><em>pArrayItemDefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint[]&#160;</td>
          <td class="paramname"><em>punArrayQuantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>unArrayLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>INVENTORY ASYNC MODIFICATION</p>
<p><a class="el" href="class_steamworks_1_1_steam_inventory.html#ae05c95022ae2c610dc575da4252e9fca">GenerateItems()</a> creates one or more items and then generates a SteamInventoryCallback_t</p>
<p>notification with a matching nCallbackContext parameter. This API is only intended</p>
<p>for prototyping - it is only usable by Steam accounts that belong to the publisher group</p>
<p>for your game.</p>
<p>If punArrayQuantity is not NULL, it should be the same length as pArrayItems and should</p>
<p>describe the quantity of each item to generate.</p>

</div>
</div>
<a class="anchor" id="a0c525e42e012f03a76c4eb5fbd989f26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.GetAllItems </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>INVENTORY ASYNC QUERY</p>
<p>Captures the entire state of the current user's Steam inventory.</p>
<p>You must call DestroyResult on this handle when you are done with it.</p>
<p>Returns false and sets *pResultHandle to zero if inventory is unavailable.</p>
<p>Note: calls to this function are subject to rate limits and may return</p>
<p>cached results if called too frequently. It is suggested that you call</p>
<p>this function only when you are about to display the user's full inventory,</p>
<p>or if you expect that the inventory may have changed.</p>

</div>
</div>
<a class="anchor" id="a8cf3d4cf9600484eb407b00e8749bb75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.GetEligiblePromoItemDefinitionIDs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_c_steam_i_d.html">CSteamID</a>&#160;</td>
          <td class="paramname"><em>steamID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[]&#160;</td>
          <td class="paramname"><em>pItemDefIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>punItemDefIDsArraySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>After handling a <a class="el" href="struct_steamworks_1_1_steam_inventory_eligible_promo_item_def_i_ds__t.html">SteamInventoryEligiblePromoItemDefIDs_t</a> call result, use this</p>
<p>function to pull out the list of item definition ids that the user can be</p>
<p>manually granted via the <a class="el" href="class_steamworks_1_1_steam_inventory.html#a9a5959720e8bb143147312eb58d876f7">AddPromoItems()</a> call.</p>

</div>
</div>
<a class="anchor" id="aad7a17b85a76a5b96bdf7e2952e58704"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.GetItemDefinitionIDs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>[]&#160;</td>
          <td class="paramname"><em>pItemDefIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out uint&#160;</td>
          <td class="paramname"><em>punItemDefIDsArraySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>GetItemDefinitionIDs returns the set of all defined item definition IDs (which are</p>
<p>defined via <a class="el" href="namespace_steamworks.html">Steamworks</a> configuration, and not necessarily contiguous integers).</p>
<p>If pItemDefIDs is null, the call will return true and *punItemDefIDsArraySize will</p>
<p>contain the total size necessary for a subsequent call. Otherwise, the call will</p>
<p>return false if and only if there is not enough space in the output array.</p>

</div>
</div>
<a class="anchor" id="a9b8ae71ee266a730049776224cb99574"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.GetItemDefinitionProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>&#160;</td>
          <td class="paramname"><em>iDefinition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pchPropertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out string&#160;</td>
          <td class="paramname"><em>pchValueBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>punValueBufferSizeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>GetItemDefinitionProperty returns a string property from a given item definition.</p>
<p>Note that some properties (for example, "name") may be localized and will depend</p>
<p>on the current Steam language settings (see ISteamApps::GetCurrentGameLanguage).</p>
<p>Property names are always composed of ASCII letters, numbers, and/or underscores.</p>
<p>Pass a NULL pointer for pchPropertyName to get a comma - separated list of available</p>
<p>property names. If pchValueBuffer is NULL, *punValueBufferSize will contain the</p>
<p>suggested buffer size. Otherwise it will be the number of bytes actually copied</p>
<p>to pchValueBuffer. If the results do not fit in the given buffer, partial</p>
<p>results may be copied.</p>

</div>
</div>
<a class="anchor" id="aa4324bfdac5e0b51f46a7d462cd5e6db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.GetItemsByID </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>[]&#160;</td>
          <td class="paramname"><em>pInstanceIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>unCountInstanceIDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Captures the state of a subset of the current user's Steam inventory,</p>
<p>identified by an array of item instance IDs. The results from this call</p>
<p>can be serialized and passed to other players to "prove" that the current</p>
<p>user owns specific items, without exposing the user's entire inventory.</p>
<p>For example, you could call GetItemsByID with the IDs of the user's</p>
<p>currently equipped cosmetic items and serialize this to a buffer, and</p>
<p>then transmit this buffer to other players upon joining a game.</p>

</div>
</div>
<a class="anchor" id="af3be0bc2460ecd32ffba301703616ad3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.GetResultItemProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>resultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>unItemIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pchPropertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out string&#160;</td>
          <td class="paramname"><em>pchValueBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>punValueBufferSizeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>In combination with GetResultItems, you can use GetResultItemProperty to retrieve</p>
<p>dynamic string properties for a given item returned in the result set.</p>
<p>Property names are always composed of ASCII letters, numbers, and/or underscores.</p>
<p>Pass a NULL pointer for pchPropertyName to get a comma - separated list of available</p>
<p>property names.</p>
<p>If pchValueBuffer is NULL, *punValueBufferSize will contain the</p>
<p>suggested buffer size. Otherwise it will be the number of bytes actually copied</p>
<p>to pchValueBuffer. If the results do not fit in the given buffer, partial</p>
<p>results may be copied.</p>

</div>
</div>
<a class="anchor" id="a2ba52fdab1a05f490d8d262b76d24276"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.GetResultItems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>resultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_details__t.html">SteamItemDetails_t</a>[]&#160;</td>
          <td class="paramname"><em>pOutItemsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>punOutItemsArraySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Copies the contents of a result set into a flat array. The specific</p>
<p>contents of the result set depend on which query which was used.</p>

</div>
</div>
<a class="anchor" id="a59adc6a4bbbdc208ff0e6333ef034b41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_steamworks.html#aa3f8a4f6fec6a62bc154bbaab3cb7522">EResult</a> Steamworks.SteamInventory.GetResultStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>resultHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>INVENTORY ASYNC RESULT MANAGEMENT</p>
<p>Asynchronous inventory queries always output a result handle which can be used with</p>
<p>GetResultStatus, GetResultItems, etc. A <a class="el" href="struct_steamworks_1_1_steam_inventory_result_ready__t.html">SteamInventoryResultReady_t</a> callback will</p>
<p>be triggered when the asynchronous result becomes ready (or fails).</p>
<p>Find out the status of an asynchronous inventory result handle. Possible values:</p>
<p>k_EResultPending - still in progress</p>
<p>k_EResultOK - done, result ready</p>
<p>k_EResultExpired - done, result ready, maybe out of date (see DeserializeResult)</p>
<p>k_EResultInvalidParam - ERROR: invalid API call parameters</p>
<p>k_EResultServiceUnavailable - ERROR: service temporarily down, you may retry later</p>
<p>k_EResultLimitExceeded - ERROR: operation would exceed per-user inventory limits</p>
<p>k_EResultFail - ERROR: unknown / generic error</p>

</div>
</div>
<a class="anchor" id="ab3eb4a3d0eab8b2ba39ce461a2027851"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint Steamworks.SteamInventory.GetResultTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>resultHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Returns the server time at which the result was generated. Compare against</p>
<p>the value of IClientUtils::GetServerRealTime() to determine age.</p>

</div>
</div>
<a class="anchor" id="aa3409a61317f1e9ec0d8c2aedf7372e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.GrantPromoItems </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><a class="el" href="class_steamworks_1_1_steam_inventory.html#aa3409a61317f1e9ec0d8c2aedf7372e7">GrantPromoItems()</a> checks the list of promotional items for which the user may be eligible</p>
<p>and grants the items (one time only). On success, the result set will include items which</p>
<p>were granted, if any. If no items were granted because the user isn't eligible for any</p>
<p>promotions, this is still considered a success.</p>

</div>
</div>
<a class="anchor" id="a8b4d1ecc084ec1a9be1983d6edc73ecb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.LoadItemDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>ITEM DEFINITIONS</p>
<p>Item definitions are a mapping of "definition IDs" (integers between 1 and 1000000)</p>
<p>to a set of string properties. Some of these properties are required to display items</p>
<p>on the Steam community web site. Other properties can be defined by applications.</p>
<p>Use of these functions is optional; there is no reason to call LoadItemDefinitions</p>
<p>if your game hardcodes the numeric definition IDs (eg, purple face mask = 20, blue</p>
<p>weapon mod = 55) and does not allow for adding new item types without a client patch.</p>
<p>LoadItemDefinitions triggers the automatic load and refresh of item definitions.</p>
<p>Every time new item definitions are available (eg, from the dynamic addition of new</p>
<p>item types while players are still in-game), a <a class="el" href="struct_steamworks_1_1_steam_inventory_definition_update__t.html">SteamInventoryDefinitionUpdate_t</a></p>
<p>callback will be fired.</p>

</div>
</div>
<a class="anchor" id="a48ed0aaa8b1268ea14bdfadfd90e8e51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_steamworks_1_1_steam_a_p_i_call__t.html">SteamAPICall_t</a> Steamworks.SteamInventory.RequestEligiblePromoItemDefinitionsIDs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_c_steam_i_d.html">CSteamID</a>&#160;</td>
          <td class="paramname"><em>steamID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Request the list of "eligible" promo items that can be manually granted to the given</p>
<p>user. These are promo items of type "manual" that won't be granted automatically.</p>
<p>An example usage of this is an item that becomes available every week.</p>

</div>
</div>
<a class="anchor" id="aa2bcfa59dbc3b372c5532de814eeb785"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Steamworks.SteamInventory.SendItemDropHeartbeat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>TIMED DROPS AND PLAYTIME CREDIT</p>
<p>Deprecated. Calling this method is not required for proper playtime accounting.</p>

</div>
</div>
<a class="anchor" id="a4fa7d01a9f1c9618074b9305d1f4d08f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.SerializeResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>resultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>pOutBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out uint&#160;</td>
          <td class="paramname"><em>punOutBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>RESULT SERIALIZATION AND AUTHENTICATION</p>
<p>Serialized result sets contain a short signature which can't be forged</p>
<p>or replayed across different game sessions. A result set can be serialized</p>
<p>on the local client, transmitted to other players via your game networking,</p>
<p>and deserialized by the remote players. This is a secure way of preventing</p>
<p>hackers from lying about posessing rare/high-value items.</p>
<p>Serializes a result set with signature bytes to an output buffer. Pass</p>
<p>NULL as an output buffer to get the required size via punOutBufferSize.</p>
<p>The size of a serialized result depends on the number items which are being</p>
<p>serialized. When securely transmitting items to other players, it is</p>
<p>recommended to use "GetItemsByID" first to create a minimal result set.</p>
<p>Results have a built-in timestamp which will be considered "expired" after</p>
<p>an hour has elapsed. See DeserializeResult for expiration handling.</p>

</div>
</div>
<a class="anchor" id="a4cd5542782c2e5ce0ce6ab72a4c68856"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.TradeItems </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_c_steam_i_d.html">CSteamID</a>&#160;</td>
          <td class="paramname"><em>steamIDTradePartner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>[]&#160;</td>
          <td class="paramname"><em>pArrayGive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint[]&#160;</td>
          <td class="paramname"><em>pArrayGiveQuantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nArrayGiveLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>[]&#160;</td>
          <td class="paramname"><em>pArrayGet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint[]&#160;</td>
          <td class="paramname"><em>pArrayGetQuantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>nArrayGetLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>IN-GAME TRADING</p>
<p><a class="el" href="class_steamworks_1_1_steam_inventory.html#a4cd5542782c2e5ce0ce6ab72a4c68856">TradeItems()</a> implements limited in-game trading of items, if you prefer not to use</p>
<p>the overlay or an in-game web browser to perform Steam Trading through the website.</p>
<p>You should implement a UI where both players can see and agree to a trade, and then</p>
<p>each client should call TradeItems simultaneously (+/- 5 seconds) with matching</p>
<p>(but reversed) parameters. The result is the same as if both players performed a</p>
<p>Steam Trading transaction through the web. Each player will get an inventory result</p>
<p>confirming the removal or quantity changes of the items given away, and the new</p>
<p>item instance id numbers and quantities of the received items.</p>
<p>(Note: new item instance IDs are generated whenever an item changes ownership.)</p>

</div>
</div>
<a class="anchor" id="afcd2236b70d13598619d122696b4bcff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.TransferItemQuantity </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>&#160;</td>
          <td class="paramname"><em>itemIdSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>unQuantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_instance_i_d__t.html">SteamItemInstanceID_t</a>&#160;</td>
          <td class="paramname"><em>itemIdDest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><a class="el" href="class_steamworks_1_1_steam_inventory.html#afcd2236b70d13598619d122696b4bcff">TransferItemQuantity()</a> is intended for use with items which are "stackable" (can have</p>
<p>quantity greater than one). It can be used to split a stack into two, or to transfer</p>
<p>quantity from one stack into another stack of identical items. To split one stack into</p>
<p>two, pass k_SteamItemInstanceIDInvalid for itemIdDest and a new item will be generated.</p>

</div>
</div>
<a class="anchor" id="af1ebb38efa007f6189382f0a55dc35ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Steamworks.SteamInventory.TriggerItemDrop </td>
          <td>(</td>
          <td class="paramtype">out <a class="el" href="struct_steamworks_1_1_steam_inventory_result__t.html">SteamInventoryResult_t</a>&#160;</td>
          <td class="paramname"><em>pResultHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_steamworks_1_1_steam_item_def__t.html">SteamItemDef_t</a>&#160;</td>
          <td class="paramname"><em>dropListDefinition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Playtime credit must be consumed and turned into item drops by your game. Only item</p>
<p>definitions which are marked as "playtime item generators" can be spawned. The call</p>
<p>will return an empty result set if there is not enough playtime credit for a drop.</p>
<p>Your game should call TriggerItemDrop at an appropriate time for the user to receive</p>
<p>new items, such as between rounds or while the player is dead. Note that players who</p>
<p>hack their clients could modify the value of "dropListDefinition", so do not use it</p>
<p>to directly control rarity.</p>
<p>See your <a class="el" href="namespace_steamworks.html">Steamworks</a> configuration to set playtime drop rates for individual itemdefs.</p>
<p>The client library will suppress too-frequent calls to this method.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>KSP/Assets/Plugins/Steamworks.NET/autogen/<a class="el" href="isteaminventory_8cs.html">isteaminventory.cs</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><div style="text-align: left;float:left;">API Download: <a href="./html.zip" target="_blank">HTML</a> | <a href="./xml.zip" target="_blank">XML</a></div><small>
Generated on Tue Nov 1 2022 18:36:45 for Kerbal Space Program by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
