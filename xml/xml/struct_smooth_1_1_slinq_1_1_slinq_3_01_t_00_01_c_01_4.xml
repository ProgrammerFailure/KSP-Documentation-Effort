<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.7">
  <compounddef id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4" kind="struct" prot="public">
    <compoundname>Smooth::Slinq::Slinq&lt; T, C &gt;</compoundname>
    <templateparamlist>
      <param>
        <type>T</type>
      </param>
      <param>
        <type><ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref></type>
      </param>
    </templateparamlist>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a040986b4336e5cdc381bc51bedc2b3a6" prot="public" static="no" mutable="no">
        <type><ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref></type>
        <definition>C Smooth.Slinq.Slinq&lt; T, C &gt;.context</definition>
        <argsstring></argsstring>
        <name>context</name>
        <briefdescription>
<para><ref refid="class_part" kindref="compound">Part</ref> of the internal API. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="58" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aed7fd401eb0824b36bb9c780d2e8810d" prot="public" static="no" mutable="no">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.current</definition>
        <argsstring></argsstring>
        <name>current</name>
        <briefdescription>
<para>Either a Some option containing the current value of the enumeration, or a None option if the enumeration is complete. </para>        </briefdescription>
        <detaileddescription>
<para>Note: This is a public field for reasons concerning the internal API and should not be modified by user code. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="81" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="81" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a3550123204c9b96ff5197b8e47641374" prot="public" static="no" mutable="no">
        <type>readonly Mutator&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>readonly Mutator&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.dispose</definition>
        <argsstring></argsstring>
        <name>dispose</name>
        <briefdescription>
<para><ref refid="class_part" kindref="compound">Part</ref> of the internal API. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="53" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a45018aa0e6d57ad2647143de1ff72b1e" prot="public" static="no" mutable="no">
        <type>readonly Mutator&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>readonly Mutator&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.remove</definition>
        <argsstring></argsstring>
        <name>remove</name>
        <briefdescription>
<para><ref refid="class_part" kindref="compound">Part</ref> of the internal API. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="48" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abcfe508b6c2d17131fa3dabb6de9ba19" prot="public" static="no" mutable="no">
        <type>readonly Mutator&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>readonly Mutator&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.skip</definition>
        <argsstring></argsstring>
        <name>skip</name>
        <briefdescription>
<para><ref refid="class_part" kindref="compound">Part</ref> of the internal API. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="43" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="43" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aa5717fed01a0354fa9b893cc282a1f77" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; T &gt;</type>
        <definition>LinkedHeadTail&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo</definition>
        <argsstring>(LinkedHeadTail&lt; T &gt; list)</argsstring>
        <name>AddTo</name>
        <param>
          <type>LinkedHeadTail&lt; T &gt;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified LinkedHeadTail&lt;T&gt; and returns the result. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1515" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1515" bodyend="1528"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a45608c1cc54ae114876e2ff211530a81" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>IC</type>
        <definition>IC Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; IC &gt;</definition>
        <argsstring>(IC collection)</argsstring>
        <name>AddTo&lt; IC &gt;</name>
        <param>
          <type>IC</type>
          <declname>collection</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified collection and returns the collection. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1446" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1446" bodyend="1452"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a54c6a54f5f67757c583c9369260c93af" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Disposable&lt; IC &gt;</type>
        <definition>Disposable&lt;IC&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; IC &gt;</definition>
        <argsstring>(Disposable&lt; IC &gt; collection)</argsstring>
        <name>AddTo&lt; IC &gt;</name>
        <param>
          <type>Disposable&lt; IC &gt;</type>
          <declname>collection</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified collection and returns the collection. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1459" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1459" bodyend="1462"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1acb3c3ef797ed4b24cb54783c61836f53" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; K, T &gt;</type>
        <definition>LinkedHeadTail&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; K &gt;</definition>
        <argsstring>(LinkedHeadTail&lt; K, T &gt; list, DelegateFunc&lt; T, K &gt; selector)</argsstring>
        <name>AddTo&lt; K &gt;</name>
        <param>
          <type>LinkedHeadTail&lt; K, T &gt;</type>
          <declname>list</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified LinkedHeadTail&lt;K, T&gt; using the specified key selector and returns the result. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1560" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1560" bodyend="1573"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a982cd8a87ca08724d7a5a6f9db639f06" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Lookup&lt; K, T &gt;</type>
        <definition>Lookup&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; K &gt;</definition>
        <argsstring>(Lookup&lt; K, T &gt; lookup, DelegateFunc&lt; T, K &gt; selector)</argsstring>
        <name>AddTo&lt; K &gt;</name>
        <param>
          <type>Lookup&lt; K, T &gt;</type>
          <declname>lookup</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified Lookup&lt;K, T&gt; using the specified key selector and returns the lookup. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1650" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1650" bodyend="1656"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a4a3af8a8d5245d4ac02900f7a6cc6011" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; K, T &gt;</type>
        <definition>LinkedHeadTail&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; K, P &gt;</definition>
        <argsstring>(LinkedHeadTail&lt; K, T &gt; list, DelegateFunc&lt; T, P, K &gt; selector, P parameter)</argsstring>
        <name>AddTo&lt; K, P &gt;</name>
        <param>
          <type>LinkedHeadTail&lt; K, T &gt;</type>
          <declname>list</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified LinkedHeadTail&lt;K, T&gt; using the specified key selector and returns the result. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1580" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1580" bodyend="1593"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a038b7f071ba981fb2de616db281de2f8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Lookup&lt; K, T &gt;</type>
        <definition>Lookup&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; K, P &gt;</definition>
        <argsstring>(Lookup&lt; K, T &gt; lookup, DelegateFunc&lt; T, P, K &gt; selector, P parameter)</argsstring>
        <name>AddTo&lt; K, P &gt;</name>
        <param>
          <type>Lookup&lt; K, T &gt;</type>
          <declname>lookup</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified Lookup&lt;K, T&gt; using the specified key selector and returns the lookup. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1663" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1663" bodyend="1669"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a3c3a84240ae331aabc336471fb3328e0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>IC</type>
        <definition>IC Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; U, IC &gt;</definition>
        <argsstring>(IC collection, DelegateFunc&lt; T, U &gt; selector)</argsstring>
        <name>AddTo&lt; U, IC &gt;</name>
        <param>
          <type>IC</type>
          <declname>collection</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, U &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified collection using the specified selector and returns the collection. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1469" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1469" bodyend="1475"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a448795a5c070fad9d09e063d1a3c10b5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Disposable&lt; IC &gt;</type>
        <definition>Disposable&lt;IC&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; U, IC &gt;</definition>
        <argsstring>(Disposable&lt; IC &gt; collection, DelegateFunc&lt; T, U &gt; selector)</argsstring>
        <name>AddTo&lt; U, IC &gt;</name>
        <param>
          <type>Disposable&lt; IC &gt;</type>
          <declname>collection</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, U &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified collection using the specified selector and returns the collection. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1482" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1482" bodyend="1485"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adb7fc1eb8c18a4048e732662c09ca5d2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>IC</type>
        <definition>IC Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; U, IC, P &gt;</definition>
        <argsstring>(IC collection, DelegateFunc&lt; T, P, U &gt; selector, P parameter)</argsstring>
        <name>AddTo&lt; U, IC, P &gt;</name>
        <param>
          <type>IC</type>
          <declname>collection</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, P, U &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified collection using the specified selector and returns the collection. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1492" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1492" bodyend="1498"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a465f6fc7cac9629fa785421e77c360a5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Disposable&lt; IC &gt;</type>
        <definition>Disposable&lt;IC&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddTo&lt; U, IC, P &gt;</definition>
        <argsstring>(Disposable&lt; IC &gt; collection, DelegateFunc&lt; T, P, U &gt; selector, P parameter)</argsstring>
        <name>AddTo&lt; U, IC, P &gt;</name>
        <param>
          <type>Disposable&lt; IC &gt;</type>
          <declname>collection</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, P, U &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified collection using the specified selector and returns the collection. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1505" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1505" bodyend="1508"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abcfee903a11bc6857a8b04eba6df13fa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; T &gt;</type>
        <definition>LinkedHeadTail&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddToReverse</definition>
        <argsstring>(LinkedHeadTail&lt; T &gt; list)</argsstring>
        <name>AddToReverse</name>
        <param>
          <type>LinkedHeadTail&lt; T &gt;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified LinkedHeadTail&lt;T&gt; in reverse order and returns the result. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1535" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1535" bodyend="1553"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ae7ce161631a72f51702ebf87635519cb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; K, T &gt;</type>
        <definition>LinkedHeadTail&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddToReverse&lt; K &gt;</definition>
        <argsstring>(LinkedHeadTail&lt; K, T &gt; list, DelegateFunc&lt; T, K &gt; selector)</argsstring>
        <name>AddToReverse&lt; K &gt;</name>
        <param>
          <type>LinkedHeadTail&lt; K, T &gt;</type>
          <declname>list</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified LinkedHeadTail&lt;K, T&gt; in reverse order using the specified key selector and returns the result. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1600" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1600" bodyend="1618"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af37565bda2eafe5a73075b8fc5eca245" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; K, T &gt;</type>
        <definition>LinkedHeadTail&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AddToReverse&lt; K, P &gt;</definition>
        <argsstring>(LinkedHeadTail&lt; K, T &gt; list, DelegateFunc&lt; T, P, K &gt; selector, P parameter)</argsstring>
        <name>AddToReverse&lt; K, P &gt;</name>
        <param>
          <type>LinkedHeadTail&lt; K, T &gt;</type>
          <declname>list</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Adds the remaining elements in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the specified LinkedHeadTail&lt;K, T&gt; in reverse order using the specified key selector and returns the result. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1625" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1625" bodyend="1643"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8a56bb6d04e8932836417b0f9d6a52ba" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.Aggregate</definition>
        <argsstring>(DelegateFunc&lt; T, T, T &gt; selector)</argsstring>
        <name>Aggregate</name>
        <param>
          <type>DelegateFunc&lt; T, T, T &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Aggregate(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="570" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="570" bodyend="572"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a102a1981fd7e8c2fc821a19362317af7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.Aggregate&lt; U &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, U &gt; selector)</argsstring>
        <name>Aggregate&lt; U &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, U &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Aggregate(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="617" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="617" bodyend="623"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a377db8307b914d03e45567a1e510104a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.Aggregate&lt; U, P &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, P, U &gt; selector, P parameter)</argsstring>
        <name>Aggregate&lt; U, P &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, P, U &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Aggregate(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="639" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="639" bodyend="645"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ad86b12f21495224b43be7bba02ffa78a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>V</type>
        <definition>V Smooth.Slinq.Slinq&lt; T, C &gt;.Aggregate&lt; U, V &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, U &gt; selector, DelegateFunc&lt; U, V &gt; resultSelector)</argsstring>
        <name>Aggregate&lt; U, V &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, U &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, V &gt;</type>
          <declname>resultSelector</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Aggregate(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="630" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="630" bodyend="632"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af3e0e1d5ece9b880069819ca80fc28f9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AggregateOrNone</definition>
        <argsstring>(DelegateFunc&lt; T, T, T &gt; selector)</argsstring>
        <name>AggregateOrNone</name>
        <param>
          <type>DelegateFunc&lt; T, T, T &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Aggregate(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="579" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="579" bodyend="591"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0051cd9f422e651bd9f1e0e6d9f9871d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.AggregateOrNone&lt; P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, T, P, T &gt; selector, P parameter)</argsstring>
        <name>AggregateOrNone&lt; P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, T, P, T &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Aggregate(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="598" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="598" bodyend="610"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a4e297bedb2dfecbe22c588f9e1c56e10" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.AggregateWhile&lt; U &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, Option&lt; U &gt;&gt; selector)</argsstring>
        <name>AggregateWhile&lt; U &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> while the selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="652" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="652" bodyend="664"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7f6eec247e80c054ba60dffcd9be97fa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.AggregateWhile&lt; U, P &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, P, Option&lt; U &gt;&gt; selector, P parameter)</argsstring>
        <name>AggregateWhile&lt; U, P &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, P, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> while the selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="671" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="671" bodyend="683"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ac1d4e3f16357349f30c9db82b05c0bde" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.All</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>All</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.All(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="690" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="690" bodyend="699"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5ba5838bb0b5387babe4ada722c5e9ae" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.All&lt; P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, bool &gt; predicate, P parameter)</argsstring>
        <name>All&lt; P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.All(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="706" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="706" bodyend="715"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8a6efeee37638b8d64b5b36cacaabf86" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.Any</definition>
        <argsstring>()</argsstring>
        <name>Any</name>
        <briefdescription>
<para>Analog to Enumerable.Any(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="722" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="722" bodyend="728"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a26153410d678ddaf4d1c9c439c76f2cb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.Any</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>Any</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Any(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="735" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="735" bodyend="744"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a76e41fb405a7ffa3e0dce985257f3f1e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.Any&lt; P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, bool &gt; predicate, P parameter)</argsstring>
        <name>Any&lt; P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Any(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="751" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="751" bodyend="760"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abad012c3ce35cc07ca97f888502dfa24" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.Contains</definition>
        <argsstring>(T value)</argsstring>
        <name>Contains</name>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Contains(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="767" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="767" bodyend="769"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aa94c39ccc06488938cdfba6351b326ed" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.Contains</definition>
        <argsstring>(T value, IEqualityComparer&lt; T &gt; comparer)</argsstring>
        <name>Contains</name>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <param>
          <type>IEqualityComparer&lt; T &gt;</type>
          <declname>comparer</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Contains(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="776" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="776" bodyend="785"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5c0f6320e468725eebd49356413f561c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int Smooth.Slinq.Slinq&lt; T, C &gt;.Count</definition>
        <argsstring>()</argsstring>
        <name>Count</name>
        <briefdescription>
<para>Analog to Enumerable.Count(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="792" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="792" bodyend="799"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a37c9b173f0463aa5bd77e3bdebcf99ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Smooth.Slinq.Slinq&lt; T, C &gt;.Dispose</definition>
        <argsstring>()</argsstring>
        <name>Dispose</name>
        <briefdescription>
<para>Sets the current value of the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to None and releases any shared resources held by the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. If the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty this will have no effect. </para>        </briefdescription>
        <detaileddescription>
<para>Slinqs are automatically disposed when they become empty, but if you are done with a <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> that still contains values, you must call <ref refid="namespace_smooth_1_1_dispose" kindref="compound">Dispose</ref> to ensure the release and/or disposal of any resources held by the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="128" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="128" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a6db3698f1bf3926726cd2e8bb89ca550" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.ElementAt</definition>
        <argsstring>(int index)</argsstring>
        <name>ElementAt</name>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.ElementAt(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="806" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="806" bodyend="808"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abadd50d9cfffbcca4c37bbe34f326997" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.ElementAtOrDefault</definition>
        <argsstring>(int index)</argsstring>
        <name>ElementAtOrDefault</name>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.ElementAtOrDefault(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="815" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="815" bodyend="817"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a2256c2f615296ad57963dfc1537e1233" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ElementAtOrNone</definition>
        <argsstring>(int index)</argsstring>
        <name>ElementAtOrNone</name>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.ElementAt(), but returns an option rather than throwing an exception if the element does not exist. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="824" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="824" bodyend="833"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aafac253e1e31c9af72e5b2b939482d67" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.First</definition>
        <argsstring>()</argsstring>
        <name>First</name>
        <briefdescription>
<para>Analog to Enumerable.First(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="840" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="840" bodyend="842"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a269fc521195397c6bf8993c518407975" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.First</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>First</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.First(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="849" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="849" bodyend="851"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a38f70b68143dec8459fe2c9ba87eb481" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.FirstOrDefault</definition>
        <argsstring>()</argsstring>
        <name>FirstOrDefault</name>
        <briefdescription>
<para>Analog to Enumerable.FirstOrDefault(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="858" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="858" bodyend="860"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7254e49ad0738cb9ce58d171841f9c01" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.FirstOrDefault</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>FirstOrDefault</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.FirstOrDefault(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="867" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="867" bodyend="869"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a19233fd7664bdbb1980e05b1ac57f683" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.FirstOrNone</definition>
        <argsstring>()</argsstring>
        <name>FirstOrNone</name>
        <briefdescription>
<para>Analog to Enumerable.First(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="876" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="876" bodyend="884"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a39382a4d3dddb61de450f5626c933cd6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.FirstOrNone</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>FirstOrNone</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.First(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="891" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="891" bodyend="896"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ab7d232919b7317f785cfa4c5334d6652" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.FirstOrNone&lt; P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, bool &gt; predicate, P parameter)</argsstring>
        <name>FirstOrNone&lt; P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.First(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="903" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="903" bodyend="908"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a937e078959612986b6ee04402d8681c5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Smooth.Slinq.Slinq&lt; T, C &gt;.ForEach</definition>
        <argsstring>(DelegateAction&lt; T &gt; action)</argsstring>
        <name>ForEach</name>
        <param>
          <type>DelegateAction&lt; T &gt;</type>
          <declname>action</declname>
        </param>
        <briefdescription>
<para>Performs the specified action on each remaining element in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="915" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="915" bodyend="920"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1afe7bf32d8b7b6123500912ccfee3ac44" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Smooth.Slinq.Slinq&lt; T, C &gt;.ForEach&lt; P &gt;</definition>
        <argsstring>(DelegateAction&lt; T, P &gt; action, P parameter)</argsstring>
        <name>ForEach&lt; P &gt;</name>
        <param>
          <type>DelegateAction&lt; T, P &gt;</type>
          <declname>action</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Performs the specified action on each remaining element in the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> with the specified parameter. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="927" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="927" bodyend="932"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0fb68aaa2bc402f63e9ac26fc136c100" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.Last</definition>
        <argsstring>()</argsstring>
        <name>Last</name>
        <briefdescription>
<para>Analog to Enumerable.Last(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="939" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="939" bodyend="941"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0a25c89bff59ce9031f5ccd278e90973" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.Last</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>Last</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Last(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="948" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="948" bodyend="950"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a17d828236aa4ceb82fe1090d3af7aa6a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.LastOrDefault</definition>
        <argsstring>()</argsstring>
        <name>LastOrDefault</name>
        <briefdescription>
<para>Analog to Enumerable.LastOrDefault(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="957" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="957" bodyend="959"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ac07e4e9d4dfb5707d182a21dcf8ba482" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.LastOrDefault</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>LastOrDefault</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.LastOrDefault(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="966" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="966" bodyend="968"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a9ea0b65903e19383a5bbab63e3527042" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.LastOrNone</definition>
        <argsstring>()</argsstring>
        <name>LastOrNone</name>
        <briefdescription>
<para>Analog to Enumerable.Last(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="975" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="975" bodyend="982"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5966bacd22e757ff7e1257bda1d91cd9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.LastOrNone</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>LastOrNone</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Last(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="989" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="989" bodyend="998"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a967efd3588bccdf59b08b8c5b83b58be" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.LastOrNone&lt; P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, bool &gt; predicate, P parameter)</argsstring>
        <name>LastOrNone&lt; P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Last(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1005" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1005" bodyend="1014"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a9c43efc5dadffabc1b4b2bd6fc20a14a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.Max</definition>
        <argsstring>()</argsstring>
        <name>Max</name>
        <briefdescription>
<para>Analog to Enumerable.Max(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1021" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1021" bodyend="1029"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a9b2536a0aa1b0434ffd54df531572c40" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MaxOrNone</definition>
        <argsstring>()</argsstring>
        <name>MaxOrNone</name>
        <briefdescription>
<para>Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1036" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1036" bodyend="1038"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7cfb247bc5ef4376b45df56389ed0034" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MaxOrNone</definition>
        <argsstring>(IComparer&lt; T &gt; comparer)</argsstring>
        <name>MaxOrNone</name>
        <param>
          <type>IComparer&lt; T &gt;</type>
          <declname>comparer</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1045" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1045" bodyend="1047"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ab7bfef982423b4d331be8397d2909658" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MaxOrNone</definition>
        <argsstring>(Comparison&lt; T &gt; comparison)</argsstring>
        <name>MaxOrNone</name>
        <param>
          <type>Comparison&lt; T &gt;</type>
          <declname>comparison</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1054" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1054" bodyend="1068"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a16d904ae7e7991f27e00a4ee5bb46acb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MaxOrNone&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector)</argsstring>
        <name>MaxOrNone&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1075" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1075" bodyend="1077"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af21f894d7ee41e7fcd35627851219c90" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MaxOrNone&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector, IComparer&lt; K &gt; comparer)</argsstring>
        <name>MaxOrNone&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>IComparer&lt; K &gt;</type>
          <declname>comparer</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1084" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1084" bodyend="1086"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5266bcb8541a3f0c85cca17caf3d0cc9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MaxOrNone&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector, Comparison&lt; K &gt; comparison)</argsstring>
        <name>MaxOrNone&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>Comparison&lt; K &gt;</type>
          <declname>comparison</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1093" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1093" bodyend="1110"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0c2c4cca71ea9465a203379332b9e0eb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MaxOrNone&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter)</argsstring>
        <name>MaxOrNone&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1117" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1117" bodyend="1119"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aea056f8acc1ca8468dce7cfe12950d5e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MaxOrNone&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter, IComparer&lt; K &gt; comparer)</argsstring>
        <name>MaxOrNone&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <param>
          <type>IComparer&lt; K &gt;</type>
          <declname>comparer</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1126" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1126" bodyend="1128"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adcfe461e98b464228dc0dcfd6d885a82" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MaxOrNone&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter, Comparison&lt; K &gt; comparison)</argsstring>
        <name>MaxOrNone&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <param>
          <type>Comparison&lt; K &gt;</type>
          <declname>comparison</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Max(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1135" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1135" bodyend="1152"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a1364ebb12a58aec7a6f39b6c69e08884" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.Min</definition>
        <argsstring>()</argsstring>
        <name>Min</name>
        <briefdescription>
<para>Analog to Enumerable.Min(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1160" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1160" bodyend="1168"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a36d22e072e56e84644976d166ed41d68" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.Min</definition>
        <argsstring>(IComparer&lt; T &gt; comparer)</argsstring>
        <name>Min</name>
        <param>
          <type>IComparer&lt; T &gt;</type>
          <declname>comparer</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1184" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1184" bodyend="1186"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8070dce22c701278c058b415362e0cb7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MinOrNone</definition>
        <argsstring>()</argsstring>
        <name>MinOrNone</name>
        <briefdescription>
<para>Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1175" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1175" bodyend="1177"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0ecd086ad2ece1255928290e951c62d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MinOrNone</definition>
        <argsstring>(Comparison&lt; T &gt; comparison)</argsstring>
        <name>MinOrNone</name>
        <param>
          <type>Comparison&lt; T &gt;</type>
          <declname>comparison</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1193" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1193" bodyend="1207"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ac53d2be4913f0c6fd6b751fa444c9c67" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MinOrNone&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector)</argsstring>
        <name>MinOrNone&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1214" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1214" bodyend="1216"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abc6a1898a24190ec249481304e718fff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MinOrNone&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector, IComparer&lt; K &gt; comparer)</argsstring>
        <name>MinOrNone&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>IComparer&lt; K &gt;</type>
          <declname>comparer</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1223" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1223" bodyend="1225"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aedc5594fc6fa4ff2f80fd6c3aa3eac3e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MinOrNone&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector, Comparison&lt; K &gt; comparison)</argsstring>
        <name>MinOrNone&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>Comparison&lt; K &gt;</type>
          <declname>comparison</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1232" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1232" bodyend="1249"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1acda7935fd85bcdae78fe7cd5b2834f09" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MinOrNone&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter)</argsstring>
        <name>MinOrNone&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1256" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1256" bodyend="1258"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7beb287f64ed65934cd9c123a57d8b7a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MinOrNone&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter, IComparer&lt; K &gt; comparer)</argsstring>
        <name>MinOrNone&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <param>
          <type>IComparer&lt; K &gt;</type>
          <declname>comparer</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1265" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1265" bodyend="1267"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a47de309c42a5c519a0fb6476450fd75c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.MinOrNone&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter, Comparison&lt; K &gt; comparison)</argsstring>
        <name>MinOrNone&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <param>
          <type>Comparison&lt; K &gt;</type>
          <declname>comparison</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.Min(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty and T is a value type. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1274" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1274" bodyend="1291"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aacd26052d327727005e23ce83edd2cc5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Smooth.Slinq.Slinq&lt; T, C &gt;.Remove</definition>
        <argsstring>()</argsstring>
        <name>Remove</name>
        <briefdescription>
<para>Removes the current element from the underlying sequence and moves the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the next element in the enumeration. If the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty this will have no effect. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="106" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="106" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aac9c701b3241591f60c725d4f9133207" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.Remove</definition>
        <argsstring>(int count)</argsstring>
        <name>Remove</name>
        <param>
          <type>int</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>Enumerates up to the specified number of elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence. </para>        </briefdescription>
        <detaileddescription>
<para>If count is greater than or equal to the number of elements remaining, all the remaining elements will be removed.</para><para>If count is less than or equal to zero, no elements will be removed.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned count elements further along the enumeration. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="292" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="292" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a609818a66a57a0eee109c9bc1a313578" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.Remove</definition>
        <argsstring>(int count, DelegateAction&lt; T &gt; then)</argsstring>
        <name>Remove</name>
        <param>
          <type>int</type>
          <declname>count</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T &gt;</type>
          <declname>then</declname>
        </param>
        <briefdescription>
<para>Enumerates up to the specified number of elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element.</para><para>If count is greater than or equal to the number of elements remaining, all the remaining elements will be removed.</para><para>If count is less than or equal to zero, no elements will be removed.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned count elements further along the enumeration. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="311" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="311" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a99b3668eda467e9f4d4e11d44cbfe19a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.Remove&lt; P &gt;</definition>
        <argsstring>(int count, DelegateAction&lt; T, P &gt; then, P thenParameter)</argsstring>
        <name>Remove&lt; P &gt;</name>
        <param>
          <type>int</type>
          <declname>count</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T, P &gt;</type>
          <declname>then</declname>
        </param>
        <param>
          <type>P</type>
          <declname>thenParameter</declname>
        </param>
        <briefdescription>
<para>Enumerates up to the specified number of elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element and the specified then parameter.</para><para>If count is greater than or equal to the number of elements remaining, all the remaining elements will be removed.</para><para>If count is less than or equal to zero, no elements will be removed.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned count elements further along the enumeration. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="332" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="332" bodyend="339"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a98623abee28c5a03aeaf138bc13fb9c4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveAll</definition>
        <argsstring>()</argsstring>
        <name>RemoveAll</name>
        <briefdescription>
<para>Enumerates the remaining elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>, removes them from the underlying sequence, and returns the number of elements removed. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="235" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="235" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adfd8dc3e8fc5f2310c7a38f01e030f3d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveAll</definition>
        <argsstring>(DelegateAction&lt; T &gt; then)</argsstring>
        <name>RemoveAll</name>
        <param>
          <type>DelegateAction&lt; T &gt;</type>
          <declname>then</declname>
        </param>
        <briefdescription>
<para>Enumerates the remaining elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>, removes them from the underlying sequence, and returns the number of elements removed. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element.</para><para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="252" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="252" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a71fadcecadec307fa4c819322a1afacf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveAll&lt; P &gt;</definition>
        <argsstring>(DelegateAction&lt; T, P &gt; then, P thenParameter)</argsstring>
        <name>RemoveAll&lt; P &gt;</name>
        <param>
          <type>DelegateAction&lt; T, P &gt;</type>
          <declname>then</declname>
        </param>
        <param>
          <type>P</type>
          <declname>thenParameter</declname>
        </param>
        <briefdescription>
<para>Enumerates the remaining elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>, removes them from the underlying sequence, and returns the number of elements removed. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element and the specified then parameter.</para><para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="271" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="271" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a64937470a8b2cbbbc0bd838938d45815" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveAndReturn</definition>
        <argsstring>()</argsstring>
        <name>RemoveAndReturn</name>
        <briefdescription>
<para>Removes the current element from the underlying sequence, moves the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the next element in the enumeration, and returns the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. If the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty this will have no effect. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="116" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="116" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8578335bf3c0301aa1fc8b222605ddc8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>RemoveWhile</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Enumerates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified predicate returns true. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="347" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="347" bodyend="352"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a780aec0feb2545e9c0ab6b3222007de7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate, DelegateAction&lt; T &gt; then)</argsstring>
        <name>RemoveWhile</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T &gt;</type>
          <declname>then</declname>
        </param>
        <briefdescription>
<para>Enumerates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified predicate returns true. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="362" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="362" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a9b0bb7b16ad71e7cd5088719501cde4c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate, DelegateAction&lt; T, P &gt; then, P thenParameter)</argsstring>
        <name>RemoveWhile&lt; P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T, P &gt;</type>
          <declname>then</declname>
        </param>
        <param>
          <type>P</type>
          <declname>thenParameter</declname>
        </param>
        <briefdescription>
<para>Enumerates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified predicate returns true. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element and the specifed then parameter.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="379" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="379" bodyend="386"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aed3f071a1e5732f69227297d37a9a379" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, bool &gt; predicate, P parameter)</argsstring>
        <name>RemoveWhile&lt; P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Enumerates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified predicate returns true. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="394" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="394" bodyend="399"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aefb70c185be0a245d2559b9ac9b29793" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, bool &gt; predicate, P parameter, DelegateAction&lt; T &gt; then)</argsstring>
        <name>RemoveWhile&lt; P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T &gt;</type>
          <declname>then</declname>
        </param>
        <briefdescription>
<para>Enumerates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified predicate returns true. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="409" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="409" bodyend="416"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a57ef3bfd12a2b5cd663dff9636392287" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; P, P2 &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, bool &gt; predicate, P parameter, DelegateAction&lt; T, P2 &gt; then, P2 thenParameter)</argsstring>
        <name>RemoveWhile&lt; P, P2 &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T, P2 &gt;</type>
          <declname>then</declname>
        </param>
        <param>
          <type>P2</type>
          <declname>thenParameter</declname>
        </param>
        <briefdescription>
<para>Enumerates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified predicate returns true. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element and the specified then parameter.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="426" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="426" bodyend="433"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a6a9dfa6b3803d03a5c4ebd4f52122fb4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; U &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, Option&lt; U &gt;&gt; selector)</argsstring>
        <name>RemoveWhile&lt; U &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="441" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="441" bodyend="452"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a044f3b5d61cd213e8649e0e3c9d48724" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; U &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, Option&lt; U &gt;&gt; selector, DelegateAction&lt; T &gt; then)</argsstring>
        <name>RemoveWhile&lt; U &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T &gt;</type>
          <declname>then</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="462" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="462" bodyend="475"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a820c90df6dbb362cfd2208e04255d8ff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; U, P &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, Option&lt; U &gt;&gt; selector, DelegateAction&lt; T, P &gt; then, P thenParameter)</argsstring>
        <name>RemoveWhile&lt; U, P &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T, P &gt;</type>
          <declname>then</declname>
        </param>
        <param>
          <type>P</type>
          <declname>thenParameter</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>After an element is removed the specified then action will be called with the element and the specified then parameter.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="485" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="485" bodyend="498"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1acc757876404c30fce56784eb63ba0b05" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; U, P &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, P, Option&lt; U &gt;&gt; selector, P parameter)</argsstring>
        <name>RemoveWhile&lt; U, P &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, P, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the selector returns None. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="506" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="506" bodyend="517"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adeef1f5dc7afe63a0828b2a9d16a9bfc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; U, P &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, P, Option&lt; U &gt;&gt; selector, P parameter, DelegateAction&lt; T &gt; then)</argsstring>
        <name>RemoveWhile&lt; U, P &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, P, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T &gt;</type>
          <declname>then</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the selector returns None. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="525" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="525" bodyend="538"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ae0bfb2741b8fcdf7dbbee5e39e8e16a4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.RemoveWhile&lt; U, P, P2 &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, P, Option&lt; U &gt;&gt; selector, P parameter, DelegateAction&lt; T, P2 &gt; then, P2 thenParameter)</argsstring>
        <name>RemoveWhile&lt; U, P, P2 &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, P, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <param>
          <type>DelegateAction&lt; T, P2 &gt;</type>
          <declname>then</declname>
        </param>
        <param>
          <type>P2</type>
          <declname>thenParameter</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and removes them from the underlying sequence while the specified selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the selector returns None. </para><para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>NotSupportedException</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> or an underlying <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> in the chain does not support element removal.</para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="546" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="546" bodyend="559"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a6a658c7dc6f4cf1d65c31207e913c6ca" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.SequenceEqual&lt; C2 &gt;</definition>
        <argsstring>(Slinq&lt; T, C2 &gt; other)</argsstring>
        <name>SequenceEqual&lt; C2 &gt;</name>
        <param>
          <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, C2 &gt;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.SequenceEqual(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1298" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1298" bodyend="1300"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a605059e5d7b3d5bb4f055058429e522d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.SequenceEqual&lt; C2 &gt;</definition>
        <argsstring>(Slinq&lt; T, C2 &gt; other, EqualityComparer&lt; T &gt; equalityComparer)</argsstring>
        <name>SequenceEqual&lt; C2 &gt;</name>
        <param>
          <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, C2 &gt;</type>
          <declname>other</declname>
        </param>
        <param>
          <type>EqualityComparer&lt; T &gt;</type>
          <declname>equalityComparer</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.SequenceEqual(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1307" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1307" bodyend="1309"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aacbd7a525dbb3e79029a3de2b8310360" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Smooth.Slinq.Slinq&lt; T, C &gt;.SequenceEqual&lt; T2, C2 &gt;</definition>
        <argsstring>(Slinq&lt; T2, C2 &gt; other, DelegateFunc&lt; T, T2, bool &gt; predicate)</argsstring>
        <name>SequenceEqual&lt; T2, C2 &gt;</name>
        <param>
          <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T2, C2 &gt;</type>
          <declname>other</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; T, T2, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Analog to Enumerable.SequenceEqual(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1316" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1316" bodyend="1337"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a469d24bcdb3daac001918157d81c2052" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.Single</definition>
        <argsstring>()</argsstring>
        <name>Single</name>
        <briefdescription>
<para>Analog to Enumerable.Single(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1344" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1344" bodyend="1346"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aeec83a91e1f16c5cd8dbb5d77c3ef0c0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T Smooth.Slinq.Slinq&lt; T, C &gt;.SingleOrDefault</definition>
        <argsstring>()</argsstring>
        <name>SingleOrDefault</name>
        <briefdescription>
<para>Analog to Enumerable.SingleOrDefault(). </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1353" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1353" bodyend="1359"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8d515e8ec1b563be34a5f9f8ca2e7b1e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; T &gt;</type>
        <definition>Option&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.SingleOrNone</definition>
        <argsstring>()</argsstring>
        <name>SingleOrNone</name>
        <briefdescription>
<para>Analog to Enumerable.Single(), but returns an option rather than throwing an exception if the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty or contains more than one element. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1366" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1366" bodyend="1380"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a6faa9e6ef90551f2a2f7013825507db7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Smooth.Slinq.Slinq&lt; T, C &gt;.Skip</definition>
        <argsstring>()</argsstring>
        <name>Skip</name>
        <briefdescription>
<para>Moves the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the next element in the enumeration. If the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty this will have no effect. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="86" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="86" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a2856394530dadc7dc6ef25d1ca3d956d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.Skip</definition>
        <argsstring>(int count)</argsstring>
        <name>Skip</name>
        <param>
          <type>int</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>Enumerates up to the specified number of elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>If count is greater than or equal to the number of elements remaining, all the remaining elements will be enumerated.</para><para>If count is less than or equal to zero, no elements will be enumerated.</para><para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned count elements further along the enumeration. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="158" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="158" bodyend="163"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a61385337561e8dfbd342f1d7db5f84e6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Smooth.Slinq.Slinq&lt; T, C &gt;.SkipAll</definition>
        <argsstring>()</argsstring>
        <name>SkipAll</name>
        <briefdescription>
<para>Enumerates the remaining elements of the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. Useful if you want to force execution of the underlying chain. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="143" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="143" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a3c32fd8367fd102d5afd65d69a1e7db5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.SkipAndReturn</definition>
        <argsstring>()</argsstring>
        <name>SkipAndReturn</name>
        <briefdescription>
<para>Moves the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the next element in the enumeration and returns the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. If the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> is empty this will have no effect. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="95" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="95" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7f0148e3beedc22cb155b3058d98b0f0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.SkipWhile</definition>
        <argsstring>(DelegateFunc&lt; T, bool &gt; predicate)</argsstring>
        <name>SkipWhile</name>
        <param>
          <type>DelegateFunc&lt; T, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>Enumerates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> while the specified predicate returns true. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="170" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="170" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adf4a15ce49694cfb6581fbf968835384" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
        <definition>Slinq&lt;T, C&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.SkipWhile&lt; P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, bool &gt; predicate, P parameter)</argsstring>
        <name>SkipWhile&lt; P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, bool &gt;</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Enumerates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> while the specified predicate returns true. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the predicate returns false. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="182" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="182" bodyend="187"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ae8999d019b733ead656896153580c4ed" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.SkipWhile&lt; U &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, Option&lt; U &gt;&gt; selector)</argsstring>
        <name>SkipWhile&lt; U &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> while the specified selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the selector returns None. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="194" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="194" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af4a9d19870b6bba7691f08d36cd2d1ed" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>U</type>
        <definition>U Smooth.Slinq.Slinq&lt; T, C &gt;.SkipWhile&lt; U, P &gt;</definition>
        <argsstring>(U seed, DelegateFunc&lt; U, T, P, Option&lt; U &gt;&gt; selector, P parameter)</argsstring>
        <name>SkipWhile&lt; U, P &gt;</name>
        <param>
          <type>U</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>DelegateFunc&lt; U, T, P, <ref refid="class_smooth_1_1_algebraics_1_1_option" kindref="compound">Option</ref>&lt; U &gt;&gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Aggregates elements from the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> while the specified selector returns a Some option. </para>        </briefdescription>
        <detaileddescription>
<para>After perfoming this operation, the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be positioned on the first element for which the selector returns None. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="212" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="212" bodyend="223"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a3ab60027d51054666f7af08a34ba11bf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>Smooth.Slinq.Slinq&lt; T, C &gt;.Slinq</definition>
        <argsstring>(Mutator&lt; T, C &gt; skip, Mutator&lt; T, C &gt; remove, Mutator&lt; T, C &gt; dispose, C context)</argsstring>
        <name>Slinq</name>
        <param>
          <type>Mutator&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
          <declname>skip</declname>
        </param>
        <param>
          <type>Mutator&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
          <declname>remove</declname>
        </param>
        <param>
          <type>Mutator&lt; T, <ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt;</type>
          <declname>dispose</declname>
        </param>
        <param>
          <type><ref refid="_discovery_info_8cs_1aa4534f4ef35a5b44e916abb50aa15070a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref></type>
          <declname>context</declname>
        </param>
        <briefdescription>
<para><ref refid="class_part" kindref="compound">Part</ref> of the internal API. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="63" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="63" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a1899ee4049591390103ff647f63f577a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_smooth_1_1_algebraics_1_1_tuple" kindref="compound">Smooth.Algebraics.Tuple</ref>&lt; LinkedHeadTail&lt; T &gt;, LinkedHeadTail&lt; T &gt; &gt;</type>
        <definition>Smooth.Algebraics.Tuple&lt;LinkedHeadTail&lt;T&gt;, LinkedHeadTail&lt;T&gt; &gt; Smooth.Slinq.Slinq&lt; T, C &gt;.SplitRight</definition>
        <argsstring>(int count)</argsstring>
        <name>SplitRight</name>
        <param>
          <type>int</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>Splits the remaining elements into a pair of lists, with the first list containing elements starting from the current position of the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> and the second list containing up to the last count elements from the end of the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>If count is greater than or equal to the number of elements remaining, the first list will be empty and the second list will contain all the remaining elements.</para><para>If count is less than or equal to zero, the first list will contain all the remaining elements and the second list will be empty.</para><para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1391" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1391" bodyend="1435"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1afe73817146d4468dc27d3037370b6c98" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; T &gt;</type>
        <definition>LinkedHeadTail&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLinked</definition>
        <argsstring>()</argsstring>
        <name>ToLinked</name>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into a singly linked list. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1676" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1676" bodyend="1678"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ad0498f229512a12c133d56e996989e34" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; K, T &gt;</type>
        <definition>LinkedHeadTail&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLinked&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector)</argsstring>
        <name>ToLinked&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into a singly linked key, value list using the specified key selector. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1694" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1694" bodyend="1696"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adbd1570c154df5e2cf48f24ea9105bc8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; K, T &gt;</type>
        <definition>LinkedHeadTail&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLinked&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter)</argsstring>
        <name>ToLinked&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into a singly linked key, value list using the specified key selector. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1703" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1703" bodyend="1705"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af9b4596cfcc6cbe10af8ef277064e7d6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; T &gt;</type>
        <definition>LinkedHeadTail&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLinkedReverse</definition>
        <argsstring>()</argsstring>
        <name>ToLinkedReverse</name>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into an order-reversed singly linked list. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1685" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1685" bodyend="1687"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a715d8b65848eaf15dff51a82e8236042" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; K, T &gt;</type>
        <definition>LinkedHeadTail&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLinkedReverse&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector)</argsstring>
        <name>ToLinkedReverse&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into an order-reversed singly linked key, value list using the specified key selector. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1712" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1712" bodyend="1714"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a25dc3e081fadb7320392c59786128b2d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkedHeadTail&lt; K, T &gt;</type>
        <definition>LinkedHeadTail&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLinkedReverse&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter)</argsstring>
        <name>ToLinkedReverse&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into an order-reversed singly linked key, value list using the specified key selector. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1721" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1721" bodyend="1723"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7792b19670a6bf07381429f803ac835e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>List&lt; T &gt;</type>
        <definition>List&lt;T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToList</definition>
        <argsstring>()</argsstring>
        <name>ToList</name>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into a List&lt;T&gt; borrowed from ListPool&lt;T&gt;. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1766" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1766" bodyend="1768"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af9bfbe00550308fe4e061cf883944929" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Lookup&lt; K, T &gt;</type>
        <definition>Lookup&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLookup&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector)</argsstring>
        <name>ToLookup&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into a lookup using the specified key selector. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1730" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1730" bodyend="1732"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5ea526b10bcd41d1c9041d331b365cc1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Lookup&lt; K, T &gt;</type>
        <definition>Lookup&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLookup&lt; K &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, K &gt; selector, IEqualityComparer&lt; K &gt; comparer)</argsstring>
        <name>ToLookup&lt; K &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>IEqualityComparer&lt; K &gt;</type>
          <declname>comparer</declname>
        </param>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into a lookup using the specified key selector and equality comparer. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1739" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1739" bodyend="1741"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a2a88afa86063defdf57db426812d4801" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Lookup&lt; K, T &gt;</type>
        <definition>Lookup&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLookup&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter)</argsstring>
        <name>ToLookup&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into a lookup using the specified key selector and equality comparer. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1748" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1748" bodyend="1750"/>
      </memberdef>
      <memberdef kind="function" id="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ae00e35527cbbff47f07e3e1c271659f8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Lookup&lt; K, T &gt;</type>
        <definition>Lookup&lt;K, T&gt; Smooth.Slinq.Slinq&lt; T, C &gt;.ToLookup&lt; K, P &gt;</definition>
        <argsstring>(DelegateFunc&lt; T, P, K &gt; selector, P parameter, IEqualityComparer&lt; K &gt; comparer)</argsstring>
        <name>ToLookup&lt; K, P &gt;</name>
        <param>
          <type>DelegateFunc&lt; T, P, K &gt;</type>
          <declname>selector</declname>
        </param>
        <param>
          <type>P</type>
          <declname>parameter</declname>
        </param>
        <param>
          <type>IEqualityComparer&lt; K &gt;</type>
          <declname>comparer</declname>
        </param>
        <briefdescription>
<para>Converts the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> into a lookup using the specified key selector and equality comparer. </para>        </briefdescription>
        <detaileddescription>
<para>This operation will consume and dispose the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="1757" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="1757" bodyend="1759"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Allocation-free enumerator with advanced, LINQ-like functionality. </para>    </briefdescription>
    <detaileddescription>
<para>The basic operations on a <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> are:</para><para>current, which is either a Some option containing the current value of the enumeration, or a None option if the enumeration is complete.</para><para>Skip, which moves the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the next element in the enumeration.</para><para>Remove, which removes the current element from the underlying representation and moves the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> to the next element in the enumeration.</para><para><ref refid="namespace_smooth_1_1_dispose" kindref="compound">Dispose</ref>, which cancels the remainder of the enumeration and releases any shared resources held by the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>.</para><para>If a Skip or Remove call completes the enumeration, any shared resources held by the <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> will be released automatically. <ref refid="namespace_smooth_1_1_dispose" kindref="compound">Dispose</ref> only needs to be called when abandoning an incomplete enumeration.</para><para><ref refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4" kindref="compound">Slinq&lt;T, C&gt;</ref> and its extension classes define many operations inspired by Linq and functional programming languages such as Scala and F#.</para><para><ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref> methods that take delegate parameter(s) come in two forms, a basic version and a version that takes an additional, user defined parameter of generic type P. This extra parameter is passed to the delegate(s) in order to capture any state required for the operation without the need for a closure.</para><para>Note: Because Slinqs are value types, it is possible to backtrack to an earlier point in an enumeration by storing multiple copies of a <ref refid="class_smooth_1_1_slinq_1_1_slinq" kindref="compound">Slinq</ref>. This is not supported and will lead to unspecified behavior.</para><para>If DETECT_BACKTRACK is defined in <ref refid="struct_smooth_1_1_slinq_1_1_context_1_1_backtrack_detector" kindref="compound">Smooth.Slinq.Context.BacktrackDetector</ref>, backtracking will be detected and throw an exception. This should only be used for debugging purposes as it will severely reduce performance. </para>    </detaileddescription>
    <collaborationgraph>
      <node id="150618">
        <label>IEquatable&lt; Option&lt; T &gt;&gt;</label>
      </node>
      <node id="150615">
        <label>Smooth.Slinq.Slinq&lt; T, C &gt;</label>
        <link refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4"/>
        <childnode refid="150616" relation="usage">
          <edgelabel>current</edgelabel>
        </childnode>
      </node>
      <node id="150617">
        <label>IComparable&lt; Option&lt; T &gt;&gt;</label>
      </node>
      <node id="150616">
        <label>Smooth.Algebraics.Option&lt; T &gt;</label>
        <link refid="struct_smooth_1_1_algebraics_1_1_option_3_01_t_01_4"/>
        <childnode refid="150617" relation="public-inheritance">
        </childnode>
        <childnode refid="150618" relation="public-inheritance">
        </childnode>
        <childnode refid="150619" relation="usage">
          <edgelabel>None</edgelabel>
        </childnode>
      </node>
      <node id="150619">
        <label>static</label>
      </node>
    </collaborationgraph>
    <location file="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" line="36" column="1" bodyfile="D:/Workspace/KSP1/KSP/KSP/Assets/Scripts/Util Scripts/SmoothFoundations/Slinq/Slinq.cs" bodystart="36" bodyend="1772"/>
    <listofallmembers>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aa5717fed01a0354fa9b893cc282a1f77" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a45608c1cc54ae114876e2ff211530a81" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; IC &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a54c6a54f5f67757c583c9369260c93af" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; IC &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1acb3c3ef797ed4b24cb54783c61836f53" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a982cd8a87ca08724d7a5a6f9db639f06" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a4a3af8a8d5245d4ac02900f7a6cc6011" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a038b7f071ba981fb2de616db281de2f8" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a3c3a84240ae331aabc336471fb3328e0" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; U, IC &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a448795a5c070fad9d09e063d1a3c10b5" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; U, IC &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adb7fc1eb8c18a4048e732662c09ca5d2" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; U, IC, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a465f6fc7cac9629fa785421e77c360a5" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddTo&lt; U, IC, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abcfee903a11bc6857a8b04eba6df13fa" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddToReverse</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ae7ce161631a72f51702ebf87635519cb" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddToReverse&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af37565bda2eafe5a73075b8fc5eca245" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AddToReverse&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8a56bb6d04e8932836417b0f9d6a52ba" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Aggregate</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a102a1981fd7e8c2fc821a19362317af7" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Aggregate&lt; U &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a377db8307b914d03e45567a1e510104a" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Aggregate&lt; U, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ad86b12f21495224b43be7bba02ffa78a" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Aggregate&lt; U, V &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af3e0e1d5ece9b880069819ca80fc28f9" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AggregateOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0051cd9f422e651bd9f1e0e6d9f9871d" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AggregateOrNone&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a4e297bedb2dfecbe22c588f9e1c56e10" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AggregateWhile&lt; U &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7f6eec247e80c054ba60dffcd9be97fa" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>AggregateWhile&lt; U, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ac1d4e3f16357349f30c9db82b05c0bde" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>All</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5ba5838bb0b5387babe4ada722c5e9ae" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>All&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8a6efeee37638b8d64b5b36cacaabf86" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Any</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a26153410d678ddaf4d1c9c439c76f2cb" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Any</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a76e41fb405a7ffa3e0dce985257f3f1e" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Any&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abad012c3ce35cc07ca97f888502dfa24" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Contains</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aa94c39ccc06488938cdfba6351b326ed" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Contains</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a040986b4336e5cdc381bc51bedc2b3a6" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>context</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5c0f6320e468725eebd49356413f561c" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Count</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aed7fd401eb0824b36bb9c780d2e8810d" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>current</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a3550123204c9b96ff5197b8e47641374" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>dispose</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a37c9b173f0463aa5bd77e3bdebcf99ef" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Dispose</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a6db3698f1bf3926726cd2e8bb89ca550" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ElementAt</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abadd50d9cfffbcca4c37bbe34f326997" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ElementAtOrDefault</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a2256c2f615296ad57963dfc1537e1233" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ElementAtOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aafac253e1e31c9af72e5b2b939482d67" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>First</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a269fc521195397c6bf8993c518407975" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>First</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a38f70b68143dec8459fe2c9ba87eb481" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>FirstOrDefault</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7254e49ad0738cb9ce58d171841f9c01" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>FirstOrDefault</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a19233fd7664bdbb1980e05b1ac57f683" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>FirstOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a39382a4d3dddb61de450f5626c933cd6" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>FirstOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ab7d232919b7317f785cfa4c5334d6652" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>FirstOrNone&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a937e078959612986b6ee04402d8681c5" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ForEach</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1afe7bf32d8b7b6123500912ccfee3ac44" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ForEach&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0fb68aaa2bc402f63e9ac26fc136c100" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Last</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0a25c89bff59ce9031f5ccd278e90973" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Last</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a17d828236aa4ceb82fe1090d3af7aa6a" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>LastOrDefault</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ac07e4e9d4dfb5707d182a21dcf8ba482" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>LastOrDefault</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a9ea0b65903e19383a5bbab63e3527042" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>LastOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5966bacd22e757ff7e1257bda1d91cd9" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>LastOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a967efd3588bccdf59b08b8c5b83b58be" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>LastOrNone&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a9c43efc5dadffabc1b4b2bd6fc20a14a" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Max</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a9b2536a0aa1b0434ffd54df531572c40" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MaxOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7cfb247bc5ef4376b45df56389ed0034" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MaxOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ab7bfef982423b4d331be8397d2909658" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MaxOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a16d904ae7e7991f27e00a4ee5bb46acb" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MaxOrNone&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af21f894d7ee41e7fcd35627851219c90" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MaxOrNone&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5266bcb8541a3f0c85cca17caf3d0cc9" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MaxOrNone&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0c2c4cca71ea9465a203379332b9e0eb" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MaxOrNone&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aea056f8acc1ca8468dce7cfe12950d5e" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MaxOrNone&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adcfe461e98b464228dc0dcfd6d885a82" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MaxOrNone&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a1364ebb12a58aec7a6f39b6c69e08884" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Min</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a36d22e072e56e84644976d166ed41d68" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Min</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8070dce22c701278c058b415362e0cb7" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MinOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a0ecd086ad2ece1255928290e951c62d9" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MinOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ac53d2be4913f0c6fd6b751fa444c9c67" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MinOrNone&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abc6a1898a24190ec249481304e718fff" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MinOrNone&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aedc5594fc6fa4ff2f80fd6c3aa3eac3e" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MinOrNone&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1acda7935fd85bcdae78fe7cd5b2834f09" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MinOrNone&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7beb287f64ed65934cd9c123a57d8b7a" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MinOrNone&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a47de309c42a5c519a0fb6476450fd75c" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>MinOrNone&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aacd26052d327727005e23ce83edd2cc5" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Remove</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aac9c701b3241591f60c725d4f9133207" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Remove</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a609818a66a57a0eee109c9bc1a313578" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Remove</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a45018aa0e6d57ad2647143de1ff72b1e" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>remove</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a99b3668eda467e9f4d4e11d44cbfe19a" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Remove&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a98623abee28c5a03aeaf138bc13fb9c4" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveAll</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adfd8dc3e8fc5f2310c7a38f01e030f3d" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveAll</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a71fadcecadec307fa4c819322a1afacf" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveAll&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a64937470a8b2cbbbc0bd838938d45815" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveAndReturn</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8578335bf3c0301aa1fc8b222605ddc8" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a780aec0feb2545e9c0ab6b3222007de7" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a9b0bb7b16ad71e7cd5088719501cde4c" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aed3f071a1e5732f69227297d37a9a379" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aefb70c185be0a245d2559b9ac9b29793" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a57ef3bfd12a2b5cd663dff9636392287" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; P, P2 &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a6a9dfa6b3803d03a5c4ebd4f52122fb4" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; U &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a044f3b5d61cd213e8649e0e3c9d48724" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; U &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a820c90df6dbb362cfd2208e04255d8ff" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; U, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1acc757876404c30fce56784eb63ba0b05" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; U, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adeef1f5dc7afe63a0828b2a9d16a9bfc" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; U, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ae0bfb2741b8fcdf7dbbee5e39e8e16a4" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>RemoveWhile&lt; U, P, P2 &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a6a658c7dc6f4cf1d65c31207e913c6ca" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SequenceEqual&lt; C2 &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a605059e5d7b3d5bb4f055058429e522d" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SequenceEqual&lt; C2 &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aacbd7a525dbb3e79029a3de2b8310360" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SequenceEqual&lt; T2, C2 &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a469d24bcdb3daac001918157d81c2052" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Single</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1aeec83a91e1f16c5cd8dbb5d77c3ef0c0" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SingleOrDefault</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a8d515e8ec1b563be34a5f9f8ca2e7b1e" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SingleOrNone</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1abcfe508b6c2d17131fa3dabb6de9ba19" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>skip</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a6faa9e6ef90551f2a2f7013825507db7" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Skip</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a2856394530dadc7dc6ef25d1ca3d956d" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Skip</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a61385337561e8dfbd342f1d7db5f84e6" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SkipAll</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a3c32fd8367fd102d5afd65d69a1e7db5" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SkipAndReturn</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7f0148e3beedc22cb155b3058d98b0f0" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SkipWhile</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adf4a15ce49694cfb6581fbf968835384" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SkipWhile&lt; P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ae8999d019b733ead656896153580c4ed" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SkipWhile&lt; U &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af4a9d19870b6bba7691f08d36cd2d1ed" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SkipWhile&lt; U, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a3ab60027d51054666f7af08a34ba11bf" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>Slinq</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a1899ee4049591390103ff647f63f577a" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>SplitRight</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1afe73817146d4468dc27d3037370b6c98" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLinked</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ad0498f229512a12c133d56e996989e34" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLinked&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1adbd1570c154df5e2cf48f24ea9105bc8" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLinked&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af9b4596cfcc6cbe10af8ef277064e7d6" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLinkedReverse</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a715d8b65848eaf15dff51a82e8236042" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLinkedReverse&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a25dc3e081fadb7320392c59786128b2d" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLinkedReverse&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a7792b19670a6bf07381429f803ac835e" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToList</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1af9bfbe00550308fe4e061cf883944929" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLookup&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a5ea526b10bcd41d1c9041d331b365cc1" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLookup&lt; K &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1a2a88afa86063defdf57db426812d4801" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLookup&lt; K, P &gt;</name></member>
      <member refid="struct_smooth_1_1_slinq_1_1_slinq_3_01_t_00_01_c_01_4_1ae00e35527cbbff47f07e3e1c271659f8" prot="public" virt="non-virtual"><scope>Smooth::Slinq::Slinq&lt; T, C &gt;</scope><name>ToLookup&lt; K, P &gt;</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
